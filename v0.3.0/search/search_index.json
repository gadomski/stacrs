{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stacrs","text":"<p>A small no-dependency Python package for STAC, using Rust under the hood.</p>"},{"location":"#usage","title":"Usage","text":"<p>Install via pip:</p> <pre><code>python -m pip install stacrs\n</code></pre> <p>Then:</p> <pre><code>import stacrs\n\n# Search a STAC API\nitems = stacrs.search(\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=100,\n)\n\n# Write items to a stac-geoparquet file\nstacrs.write(\"items.parquet\", items)\n\n# Read items from a stac-geoparquet file as an item collection\nitem_collection = stacrs.read(\"items.parquet\")\n\n# Use `search_to` for better performance if you know you'll be writing the items\n# to a file\nstacrs.search_to(\n    \"items.parquet\",\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=100,\n)\n</code></pre> <p>See the documentation for details. In particular, our example notebook demonstrates some of the more interesting features.</p>"},{"location":"#comparisons","title":"Comparisons","text":"<p>This package (intentionally) has limited functionality, as it is not intended to be a replacement for existing Python STAC packages. pystac is a mature Python library with a significantly richer API for working with STAC objects. For querying STAC APIs, pystac-client is more feature-rich than our simplistic <code>stacrs.search</code>.</p> <p>That being said, it is hoped that stacrs will be a nice complement to the existing Python STAC ecosystem by providing a no-dependency package with unique capabilities, such as searching directly into a stac-geoparquet file.</p>"},{"location":"#development","title":"Development","text":"<p>Get Rust and uv. Then:</p> <pre><code>git clone git@github.com:gadomski/stacrs.git\ncd stacrs\nuv sync  # This will take a little while while the Rust dependencies build\nuv run pytest\n</code></pre> <p>See CONTRIBUTING.md for more information about contributing to this project.</p>"},{"location":"#license","title":"License","text":"<p>stacrs is dual-licensed under both the MIT license and the Apache license (Version 2.0). See LICENSE-APACHE and LICENSE-MIT for details.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to stacrs","text":"<p>First off, thanks for contributing! We appreciates you.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>We aim for comprehensive unit testing of this library. Please provide tests for any new features, or to demonstrate bugs. Draft pull requests with a failing test to demonstrate a bug are much appreciated.</p>"},{"location":"CONTRIBUTING/#submitting-changes","title":"Submitting changes","text":"<p>Please open a pull request with your changes -- make sure to include unit tests. Please follow standard git commit formatting (subject line 50 characters max, wrap the body at 72 characters).</p> <p>We use conventional commits. Your commits do not have to but if you'd like to format them this way, we would be grateful.</p> <p>If you can, use <code>git rebase -i</code> to create a clean, well-formatted history before opening your pull request. If you need to make changes after opening your pull request (e.g. to fix CI breakages) we will be grateful if you squash those fixes into their relevant commits.</p> <p>Thanks so much!</p> <p>-Pete Gadomski</p>"},{"location":"example/","title":"Example notebook","text":"In\u00a0[2]: Copied! <pre>import os.path\n\nimport stacrs\nimport humanize\n\nitems = stacrs.search(\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=1000,\n)\nstacrs.write(\"items.json\", items)  # GeoJSON feature collection\nstacrs.write(\"items.ndjson\", items)  # newline-delimited JSON\nstacrs.write(\"items.parquet\", items)  # stac-geoparquet\nstacrs.write(  # compressed stac-geoparquet\n    \"items-compressed.parquet\", items, format=\"parquet[snappy]\"\n)\n\nfor file_name in (\n    \"items.json\",\n    \"items.ndjson\",\n    \"items.parquet\",\n    \"items-compressed.parquet\",\n):\n    print(f\"{file_name}: {humanize.naturalsize(os.path.getsize(file_name))}\")\n\nitems = stacrs.read(\"items-compressed.parquet\")\nassert len(items[\"features\"]) == 1000\n</pre> import os.path  import stacrs import humanize  items = stacrs.search(     \"https://landsatlook.usgs.gov/stac-server\",     collections=\"landsat-c2l2-sr\",     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},     sortby=\"-properties.datetime\",     max_items=1000, ) stacrs.write(\"items.json\", items)  # GeoJSON feature collection stacrs.write(\"items.ndjson\", items)  # newline-delimited JSON stacrs.write(\"items.parquet\", items)  # stac-geoparquet stacrs.write(  # compressed stac-geoparquet     \"items-compressed.parquet\", items, format=\"parquet[snappy]\" )  for file_name in (     \"items.json\",     \"items.ndjson\",     \"items.parquet\",     \"items-compressed.parquet\", ):     print(f\"{file_name}: {humanize.naturalsize(os.path.getsize(file_name))}\")  items = stacrs.read(\"items-compressed.parquet\") assert len(items[\"features\"]) == 1000 <pre>items.json: 21.4 MB\nitems.ndjson: 21.4 MB\nitems.parquet: 488.2 kB\nitems-compressed.parquet: 178.8 kB\n</pre> In\u00a0[3]: Copied! <pre>import contextily\nimport stacrs\nfrom geopandas import GeoDataFrame\n\nurl = \"https://github.com/gadomski/2024-09-FOSS4G-NA-stac-rs/raw/refs/heads/main/benches/1000-sentinel-2-items-stac-rs.parquet\"\nitems = stacrs.search(\n    url, intersects={\"type\": \"Point\", \"coordinates\": [-105.1019, 40.1672]}\n)\ndata_frame = GeoDataFrame.from_features(items, crs=\"EPSG:4326\")\naxis = data_frame.plot(facecolor=\"none\")\ncontextily.add_basemap(axis, crs=data_frame.crs.to_string())\n</pre> import contextily import stacrs from geopandas import GeoDataFrame  url = \"https://github.com/gadomski/2024-09-FOSS4G-NA-stac-rs/raw/refs/heads/main/benches/1000-sentinel-2-items-stac-rs.parquet\" items = stacrs.search(     url, intersects={\"type\": \"Point\", \"coordinates\": [-105.1019, 40.1672]} ) data_frame = GeoDataFrame.from_features(items, crs=\"EPSG:4326\") axis = data_frame.plot(facecolor=\"none\") contextily.add_basemap(axis, crs=data_frame.crs.to_string()) In\u00a0[4]: Copied! <pre>stacrs.search_to(\"items-compressed.parquet\",\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=1000,\n    format=\"parquet[snappy]\",\n)\n</pre> stacrs.search_to(\"items-compressed.parquet\",     \"https://landsatlook.usgs.gov/stac-server\",     collections=\"landsat-c2l2-sr\",     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},     sortby=\"-properties.datetime\",     max_items=1000,     format=\"parquet[snappy]\", ) Out[4]: <pre>1000</pre>"},{"location":"example/#example-notebook","title":"Example notebook\u00b6","text":"<p>This notebook demonstrates some of the more interesting features of stacrs.</p>"},{"location":"example/#stac-geoparquet","title":"stac-geoparquet\u00b6","text":"<p>stac-geoparquet is a relatively new specification that describes how to store STAC items in a geoparquet. Use stacrs to read and write stac-geoparquet.</p>"},{"location":"example/#search","title":"Search\u00b6","text":"<p>As seen above, you can <code>search</code> STAC APIs. Using DuckDB, you can search stac-geoparquet files as well, both local and remote.</p>"},{"location":"example/#search-to","title":"Search to\u00b6","text":"<p>If you want to save the results of a STAC API search directly to a file, use <code>search_to</code>. This will generally be more performant than using <code>search</code> then <code>write</code>.</p>"},{"location":"api/","title":"Python API","text":"<p>API documentation for the stacrs Python package.</p>"},{"location":"api/migrate/","title":"Migration","text":""},{"location":"api/migrate/#stacrs.migrate","title":"stacrs.migrate  <code>builtin</code>","text":"<pre><code>migrate(value: dict[str, Any], version: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Migrates a STAC dictionary to another version.</p> <p>Migration can be as simple as updating the <code>stac_version</code> attribute, but sometimes can be more complicated. For example, when migrating to v1.1.0, eo:bands and raster:bands should be consolidated to the new bands structure.</p> <p>See the stac-rs documentation for supported versions.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The STAC value to migrate</p> required <code>version</code> <code>str | None</code> <p>The version to migrate to. If not provided, the value will be migrated to the latest stable version.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The migrated dictionary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"examples/simple-item.json\") as f:\n&gt;&gt;&gt;     item = json.load(f)\n&gt;&gt;&gt; item = stacrs.migrate(item, \"1.1.0-beta.1\")\n&gt;&gt;&gt; assert item[\"stac_version\"] == \"1.1.0-beta.1\"\n</code></pre>"},{"location":"api/migrate/#stacrs.migrate_href","title":"stacrs.migrate_href  <code>builtin</code>","text":"<pre><code>migrate_href(href: str, version: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Migrates a STAC dictionary at the given href to another version.</p> <p>Migration can be as simple as updating the <code>stac_version</code> attribute, but sometimes can be more complicated. For example, when migrating to v1.1.0, eo:bands and raster:bands should be consolidated to the new bands structure.</p> <p>See the stac-rs documentation for supported versions.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The href to read the STAC object from</p> required <code>version</code> <code>str | None</code> <p>The version to migrate to. If not provided, the value will be migrated to the latest stable version.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; item = stacrs.migrate_href(\"examples/simple-item.json\", \"1.1.0-beta.1\")\n&gt;&gt;&gt; assert item[\"stac_version\"] == \"1.1.0-beta.1\"\n</code></pre>"},{"location":"api/read/","title":"Read","text":""},{"location":"api/read/#stacrs.read","title":"stacrs.read  <code>builtin</code>","text":"<pre><code>read(href: str, *, format: str | None = None, options: list[tuple[str, str]] | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Reads STAC from a href.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The href to write to</p> required <code>format</code> <code>str | None</code> <p>The output format to write. If not provided, will be inferred from the href's extension.</p> <code>None</code> <code>options</code> <code>list[tuple[str, str]] | None</code> <p>Options for configuring an object store, e.g. your AWS credentials.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: The STAC value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; item = stacrs.read(\"item.json\")\n</code></pre>"},{"location":"api/search/","title":"Search","text":""},{"location":"api/search/#stacrs.search","title":"stacrs.search  <code>builtin</code>","text":"<pre><code>search(href: str, *, intersects: Optional[str | dict[str, Any]] = None, ids: Optional[str | list[str]] = None, collections: Optional[str | list[str]] = None, max_items: Optional[int] = None, limit: Optional[int] = None, bbox: Optional[list[float]] = None, datetime: Optional[str] = None, include: Optional[str | list[str]] = None, exclude: Optional[str | list[str]] = None, sortby: Optional[str | list[str]] = None, filter: Optional[str | dict[str, Any]] = None, query: Optional[dict[str, Any]] = None, use_duckdb: Optional[bool] = None) -&gt; list[dict[str, Any]]\n</code></pre> <p>Searches a STAC API server.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The STAC API to search.</p> required <code>intersects</code> <code>str | dict[str, Any] | GeoInterface | None</code> <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>Array of Item ids to return.</p> <code>None</code> <code>collections</code> <code>list[str] | None</code> <p>Array of one or more Collection IDs that each matching Item must be in.</p> <code>None</code> <code>max_items</code> <code>int | None</code> <p>The maximum number of items to iterate through.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The page size returned from the server. Use <code>max_items</code> to actually limit the number of items returned from this function.</p> <code>None</code> <code>bbox</code> <code>list[float] | None</code> <p>Requested bounding box.</p> <code>None</code> <code>datetime</code> <code>str | None</code> <p>Single date+time, or a range (<code>/</code> separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> <code>None</code> <code>include</code> <code>list[str]] | None</code> <p>fields to include in the response (see the extension docs) for more on the semantics).</p> <code>None</code> <code>exclude</code> <code>list[str]] | None</code> <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> <code>None</code> <code>sortby</code> <code>list[str] | None</code> <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> <code>None</code> <code>filter</code> <code>str | dict[str, Any] | none</code> <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> <code>None</code> <code>query</code> <code>dict[str, Any] | None</code> <p>Additional filtering based on properties. It is recommended to use filter instead, if possible.</p> <code>None</code> <code>use_duckdb</code> <code>bool | None</code> <p>Query with DuckDB. If None and the href has a 'parquet' or 'geoparquet' extension, will be set to True. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: A list of the returned STAC items.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; items = stacrs.search(\n...     \"https://landsatlook.usgs.gov/stac-server\",\n...     collections=[\"landsat-c2l2-sr\"],\n...     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n...     sortby=\"-properties.datetime\",\n...     max_items=1,\n... )\n</code></pre>"},{"location":"api/search/#stacrs.search_to","title":"stacrs.search_to  <code>builtin</code>","text":"<pre><code>search_to(outfile: str, href: str, *, intersects: Optional[str | dict[str, Any]] = None, ids: Optional[str | list[str]] = None, collections: Optional[str | list[str]] = None, max_items: Optional[int] = None, limit: Optional[int] = None, bbox: Optional[list[float]] = None, datetime: Optional[str] = None, include: Optional[str | list[str]] = None, exclude: Optional[str | list[str]] = None, sortby: Optional[str | list[str]] = None, filter: Optional[str | dict[str, Any]] = None, query: Optional[dict[str, Any]] = None, format: Optional[str] = None, options: Optional[list[Tuple[str, str]]] = None, use_duckdb: Optional[bool] = None) -&gt; int\n</code></pre> <p>Searches a STAC API server and saves the result to an output file.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str</code> <p>The output href. This can be a local file path, or any url scheme supported by [stac::object_store::write].</p> required <code>href</code> <code>str</code> <p>The STAC API to search.</p> required <code>intersects</code> <code>str | dict[str, Any] | GeoInterface | None</code> <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>Array of Item ids to return.</p> <code>None</code> <code>collections</code> <code>list[str] | None</code> <p>Array of one or more Collection IDs that each matching Item must be in.</p> <code>None</code> <code>max_items</code> <code>int | None</code> <p>The maximum number of items to iterate through.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>The page size returned from the server. Use <code>max_items</code> to actually limit the number of items returned from this function.</p> <code>None</code> <code>bbox</code> <code>list[float] | None</code> <p>Requested bounding box.</p> <code>None</code> <code>datetime</code> <code>str | None</code> <p>Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> <code>None</code> <code>include</code> <code>list[str]] | None</code> <p>fields to include in the response (see the extension docs) for more on the semantics).</p> <code>None</code> <code>exclude</code> <code>list[str]] | None</code> <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> <code>None</code> <code>sortby</code> <code>list[str] | None</code> <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> <code>None</code> <code>filter</code> <code>str | dict[str, Any] | none</code> <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> <code>None</code> <code>query</code> <code>dict[str, Any] | None</code> <p>Additional filtering based on properties. It is recommended to use filter instead, if possible.</p> <code>None</code> <code>format</code> <code>str | None</code> <p>The output format. If none, will be inferred from the outfile extension, and if that fails will fall back to compact JSON.</p> <code>None</code> <code>options</code> <code>list[tuple[str, str]] | None</code> <p>Configuration values to pass to the object store backend.</p> <code>None</code> <code>use_duckdb</code> <code>bool | None</code> <p>Query with DuckDB. If None and the href has a 'parquet' or 'geoparquet' extension, will be set to True. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>list[dict[str, Any]]: A list of the returned STAC items.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; items = stacrs.search_to(\"out.parquet\",\n...     \"https://landsatlook.usgs.gov/stac-server\",\n...     collections=[\"landsat-c2l2-sr\"],\n...     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n...     sortby=\"-properties.datetime\",\n...     max_items=1,\n... )\n</code></pre>"},{"location":"api/validate/","title":"Validate","text":""},{"location":"api/validate/#stacrs.validate","title":"stacrs.validate","text":"<pre><code>validate(value: dict[str, Any]) -&gt; None\n</code></pre> <p>Validates a STAC dictionary with json-schema.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>dict[str, Any]</code> <p>The STAC value to validate</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>On a validation error</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"examples/simple-item.json\") as f:\n&gt;&gt;&gt;     data = json.load(f)\n&gt;&gt;&gt; stacrs.validate(data)\n</code></pre>"},{"location":"api/validate/#stacrs.validate_href","title":"stacrs.validate_href","text":"<pre><code>validate_href(href: str) -&gt; None\n</code></pre> <p>Validates a single href with json-schema.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The href of the STAC value to validate</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>On any input/output error, or on a validation error</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stacrs.validate_href(\"examples/simple-item.json\")\n&gt;&gt;&gt; stacrs.validate_href(\"data/invalid-item.json\")\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nException: Validation errors: \"collection\" is a required property\n</code></pre>"},{"location":"api/version/","title":"Version","text":""},{"location":"api/version/#stacrs.version","title":"stacrs.version  <code>builtin</code>","text":"<pre><code>version(name: str | None = None) -&gt; str | None\n</code></pre> <p>Returns this package's version, or the version of a upstream.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the upstream version to return. Valid values are \"stac\", \"stac-api\", \"stac-duckdb\", or \"duckdb\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The version, or None if the name is not recognized as an upstream.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stacrs.version()\n\"0.2.0\"\n&gt;&gt;&gt; stacrs.version(\"duckdb\")\n\"1.0.0\"\n</code></pre>"},{"location":"api/write/","title":"Write","text":""},{"location":"api/write/#stacrs.write","title":"stacrs.write  <code>builtin</code>","text":"<pre><code>write(href: str, value: dict[str, Any] | list[dict[str, Any]], *, format: str | None = None, options: list[tuple[str, str]] | None = None) -&gt; dict[str, str] | None\n</code></pre> <p>Writes STAC to a href.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The href to write to</p> required <code>value</code> <code>dict[str, Any] | list[dict[str, Any]]</code> <p>The value to write. This can be a STAC dictionary or a list of items.</p> required <code>format</code> <code>str | None</code> <p>The output format to write. If not provided, will be inferred from the href's extension.</p> <code>None</code> <code>options</code> <code>list[tuple[str, str]] | None</code> <p>Options for configuring an object store, e.g. your AWS credentials.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str] | None</code> <p>dict[str, str] | None: The result of putting data into an object store, e.g. the e_tag and the version. None is returned if the file was written locally.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"items.json\") as f:\n...     items = json.load(f)\n&gt;&gt;&gt; stacrs.write(\"items.parquet\", items)\n</code></pre>"}]}